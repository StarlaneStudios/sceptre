import { createHash } from 'node:crypto';
import { join } from 'node:path/posix';
import glob from 'fast-glob';

export type Indent = 'none' | 'tab' | number;

export interface SceptreOptions {
	basePath: string;
	pattern?: string;
	indent?: Indent;
}

type SceptreConfig = Required<SceptreOptions>;

const defaultOptions: SceptreConfig = {
	basePath: './',
	pattern: './**/*.tsx',
	indent: 'none'
};

/**
 * Scan the given directory for files and generate a set of import
 * statements and 
 * @param options 
 * @returns 
 */
export function generateRoutes(options: SceptreOptions): string {
	const config = { ...defaultOptions, ...options };
	const routeMap: Record<string, string> = {};
	const files = glob.sync(config.pattern, {
		cwd: config.basePath
	});

	let output = '// ------ !!! DO NOT EDIT !!! ------\n// This file is generated by sceptre\n\n';

	for (const path of files) {
		const hash = '_' + createHash('md5').update(path).digest('hex').substring(0, 10);

		// Paths cannot be relative, prefix must be incorrect
		if (path.startsWith('.')) {
			console.warn('Invalid route path: ' + path);
			continue;
		}

		routeMap[path] = hash;

		output += `import ${hash} from './${join(config.basePath, path)}';\n`;
	}

	const index: Record<string, any> = {};
	const paths = Object.entries(routeMap);
	const routes: [string[], string][] = paths
		.sort(([a], [b]) => {
			const la = a.split('/').length;
			const lb = b.split('/').length;

			if (la - lb !== 0) {
				return la - lb;
			}

			const ua = a.split('_').length;
			const ub = b.split('_').length;

			return ub - ua;
		})
		.map(([path, value]) => [
			path.replace(/(\/@)/, '')			// Ignore @ folders
				.replace(/\/[^\/]+$/, '')		// Remove file name
				.replace(/\[(\w+)\]/g, ':$1')	// Convert [param] to :param
				.replace(/\[\.{3}\]/g, '*')		// Convert [...] to *
				.split('/'),
			value
		]);
	
	for (const [path, hash] of routes) {
		const last = path[path.length - 1];
		const isParent = last == '_';
		const segments = isParent ? path.slice(0, -1) : path;

		placeNode(index, segments, isParent, hash);
	}
	
	output += '\nexport default ' + expandNode(config, 1, index) + ';';

	return output;
}

/**
 * Attempt to place a node in a tree structure based on the
 * given path segments.
 * 
 * @param root The root object
 * @param segments The path segments
 * @param isParent Whether the node is a parent
 * @param hash The route hash
 */
function placeNode(root: any, segments: string[], isParent: boolean, hash: any) {
	let matched = false;

	for (let i = 0; i < segments.length; i++) {
		const built = segments.slice(0, i + 1).join('/');

		if (root[built] && root[built].isParent) {
			placeNode(root[built].children, segments.slice(i + 1), isParent, hash);
			matched = true;
			break;
		}
	}

	if (!matched) {
		root[segments.join('/')] = {
			children: {},
			isParent,
			hash
		};
	}
}

/**
 * Build the indent string based on the given configuration.
 * 
 * @param config The configuration	
 * @param indent The indent level
 * @returns The indent string
 */
function buildIndent(config: SceptreConfig, indent: number): string {
	if (config.indent === 'none') {
		return '';
	}

	if (config.indent === 'tab') {
		return '\n' + '\t'.repeat(indent);
	}

	return '\n' + ' '.repeat(indent * config.indent);
}

/**
 * Expand the object structure into arrays
 * of route objects.
 * 
 * @param config The configuration
 * @param indent The current indent level
 * @param root The root object
 * @returns The route objects
 */
function expandNode(config: SceptreConfig, indent: number, root: any): string {
	const entries = Object.entries(root) as [string, any][];
	
	if (entries.length === 0) {
		return '[]';
	}
	
	let result = '[';

	const prefix = buildIndent(config, indent);
	const innerPrefix = buildIndent(config, indent + 1);
	const outerPrefix = buildIndent(config, indent - 1);

	for (let i = 0; i < entries.length; i++) {
		const [path, info] = entries[i];

		result += `${prefix}{`;
		result += `${innerPrefix}...${info.hash}, `;
		result += `${innerPrefix}path: '${path}', `;
		result += `${innerPrefix}children: ${expandNode(config, indent + 2, info.children)}`;
		result += `${prefix}}`;

		if (i < entries.length - 1) {
			result += ', ';
		}
	}

	return result + outerPrefix + ']';
}