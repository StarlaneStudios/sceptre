import { createHash } from 'node:crypto';
import { relative } from 'node:path/posix';
import glob from 'fast-glob';
import { dirname, normalize, sep } from 'path/posix';

export type Indent = 'none' | 'tab' | number;

export interface SceptreOptions {
	pattern?: string;
	indent?: Indent;
	base?: string;
	forceJs?: boolean;
}

type SceptreConfig = Required<SceptreOptions>;

const defaultOptions: SceptreConfig = {
	pattern: '**/*.tsx',
	indent: 'none',
	base: '.',
	forceJs: false
};

/**
 * Scan the given directory for files and generate a routing configuration
 * 
 * @param options The options to use
 * @param target The path for imports to be relative to
 * @returns The generated routing configuration
 */
export function generateRoutes(options: SceptreOptions, target: string): string {
	const config = { ...defaultOptions, ...options };
	const routeMap: Record<string, string> = {};
	const files = glob.sync(config.pattern);

	let output = '// ------ !!! DO NOT EDIT !!! ------\n// This file is generated by sceptre\n\n';

	for (const path of files) {
		const hash = 'C_' + createHash('md5').update(path).digest('hex').substring(0, 10);
		const importPath = buildImportPath(config, path, target);
		const cleanPath = relative(config.base, normalize(path));

		if (cleanPath.startsWith('..')) {
			throw new Error(`File ${path} is outside of the base path ${config.base}`);
		}

		routeMap[cleanPath] = hash;

		output += `import ${hash} from '${importPath}';\n`;
	}

	const index: Record<string, any> = {};
	const paths = Object.entries(routeMap);
	const routes: [string[], string][] = paths
		.sort(([a], [b]) => {
			const la = a.split('/').length;
			const lb = b.split('/').length;

			if (la - lb !== 0) {
				return la - lb;
			}

			const ua = a.split('_').length;
			const ub = b.split('_').length;

			return ub - ua;
		})
		.map(([path, value]) => [
			path.replace(/@/, '')				// Ignore @ folders
				.replace(/\/[^\/]+$/, '')		// Remove file name
				.replace(/\[(\w+)\]/g, ':$1')	// Convert [param] to :param
				.replace(/\[\.{3}\]/g, '*')		// Convert [...] to *
				.split('/'),
			value
		]);
	
	for (const [path, hash] of routes) {
		const last = path[path.length - 1];
		const isParent = last == '_';
		const segments = isParent ? path.slice(0, -1) : path;

		placeNode(index, segments, isParent, hash);
	}
	
	output += '\nexport default ' + expandNode(config, 1, index) + ';';

	return output;
}

/**
 * Build the import path for the given file.
 * 
 * @param config The configuration
 * @param path The path to the file
 * @param target The path for imports to be relative to
 */
function buildImportPath(config: SceptreConfig, path: string, target: string): string {
	const relativePath = relative(dirname(target), path);
	const correctPath = relativePath.startsWith('.') ? relativePath : `.${sep}${relativePath}`;

	if (config.forceJs) {
		const lastIndex = correctPath.lastIndexOf('.');
		
		return correctPath.substring(0, lastIndex) + '.js';
	}

	return correctPath;
}

/**
 * Attempt to place a node in a tree structure based on the
 * given path segments.
 * 
 * @param root The root object
 * @param segments The path segments
 * @param isParent Whether the node is a parent
 * @param hash The route hash
 */
function placeNode(root: any, segments: string[], isParent: boolean, hash: any) {
	let matched = false;

	for (let i = 0; i < segments.length; i++) {
		const built = segments.slice(0, i + 1).join('/');

		if (root[built] && root[built].isParent) {
			placeNode(root[built].children, segments.slice(i + 1), isParent, hash);
			matched = true;
			break;
		}
	}

	if (!matched) {
		root[segments.join('/')] = {
			children: {},
			isParent,
			hash
		};
	}
}

/**
 * Build the indent string based on the given configuration.
 * 
 * @param config The configuration	
 * @param indent The indent level
 * @returns The indent string
 */
function buildIndent(config: SceptreConfig, indent: number): string {
	if (config.indent === 'none') {
		return '';
	}

	if (config.indent === 'tab') {
		return '\n' + '\t'.repeat(indent);
	}

	return '\n' + ' '.repeat(indent * config.indent);
}

/**
 * Expand the object structure into arrays
 * of route objects.
 * 
 * @param config The configuration
 * @param indent The current indent level
 * @param root The root object
 * @returns The route objects
 */
function expandNode(config: SceptreConfig, indent: number, root: any): string {
	const entries = Object.entries(root) as [string, any][];
	
	if (entries.length === 0) {
		return '[]';
	}
	
	let result = '[';

	const prefix = buildIndent(config, indent);
	const innerPrefix = buildIndent(config, indent + 1);
	const outerPrefix = buildIndent(config, indent - 1);

	for (let i = 0; i < entries.length; i++) {
		const [path, info] = entries[i];

		result += `${prefix}{`;
		result += `${innerPrefix}...${info.hash}.info, `;
		result += `${innerPrefix}element: <${info.hash} />, `;
		result += `${innerPrefix}path: '${path}', `;
		result += `${innerPrefix}children: ${expandNode(config, indent + 2, info.children)}`;
		result += `${prefix}}`;

		if (i < entries.length - 1) {
			result += ', ';
		}
	}

	return result + outerPrefix + ']';
}